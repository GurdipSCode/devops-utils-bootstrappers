#!/usr/bin/env pwsh
# ============================================================================
# Bootstrap-VaultSecrets.ps1
# Creates/updates Vault secrets for Terraform services
# Uses Vault REST API with Enterprise Namespaces (via curl.exe)
# Reads Cosign keys from local folders (generated by Generate-CosignKeys.ps1)
# Creates Lynx projects/environments if missing, then fetches credentials
# ============================================================================
#
# Usage:
#   ./Bootstrap-VaultSecrets.ps1
#   ./Bootstrap-VaultSecrets.ps1 -DryRun
#   ./Bootstrap-VaultSecrets.ps1 -CosignKeysDir "C:\Keys\cosign"
#
# Prerequisites:
#   - Cosign keys generated in local folders (run Generate-CosignKeys.ps1 first)
#   - Vault token with write access
#   - Lynx API key with write access to projects/environments
#
# Vault Namespace Structure:
#   DevOps/terraform-services/{service}/prd
#
# Secrets (KV v2 at "secret/"):
#   - cosign         (private_key, public_key, password)
#   - lynx_username  
#   - lynx_password  
#   - providers/{name}
#
# ============================================================================

param(
    [Parameter(Mandatory=$false)]
    [string]$VaultAddr = "http://vault.gssira.com:8200",
    
    [Parameter(Mandatory=$false)]
    [string]$VaultToken = "hvs.vwcrYLioLRZBO3tbsplBAMzA",
    
    [Parameter(Mandatory=$false)]
    [string]$LynxAddr = "http://lynx.gssira.com:4000",
    
    [Parameter(Mandatory=$false)]
    [string]$LynxApiKey = "25fcb438-3c25-49f4-8392-10c8f0064354",
    
    [Parameter(Mandatory=$false)]
    [string]$LynxTeamId = "",
    
    [Parameter(Mandatory=$false)]
    [string]$RootNamespace = "DevOps/terraform-services",
    
    [Parameter(Mandatory=$false)]
    [string]$KvMount = "secret",
    
    [Parameter(Mandatory=$false)]
    [string]$CosignKeysDir = ".\cosign-keys",
    
    [Parameter(Mandatory=$false)]
    [switch]$DryRun
)

$ErrorActionPreference = "Stop"

# ============================================================================
# CONFIGURATION
# ============================================================================

$services = @(
    "axiom",
    "buildkite",
    "cloudflare",
    "netlify",
    "ngrok",
    "teamcity",
    "octopusdeploy",
    "splunk",
    "elastic",
    "netbox",
    "vmware",
    "argocd",
    "cloudsmith",
    "terrapwner",
    "mondoo",
    "grafana",
    "gns3",
    "lynx",
    "archestra",
    "kestra",
    "nirmata",
    "checkly",
    "portio",
    "sentry",
    "tailscale",
    "vault",
    "harbor"
)

# ============================================================================
# COUNTERS
# ============================================================================

$script:created = 0
$script:updated = 0
$script:failed = 0
$script:lynxProjectsCreated = 0
$script:lynxEnvsCreated = 0
$script:namespacesCreated = 0

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

function Write-Header {
    param([string]$Message)
    Write-Host "`n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor Cyan
    Write-Host "  $Message" -ForegroundColor Cyan
    Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor Cyan
}

function Write-Created {
    param([string]$Message)
    Write-Host "  ‚úÖ Created: $Message" -ForegroundColor Green
    $script:created++
}

function Write-Updated {
    param([string]$Message)
    Write-Host "  üîÑ Updated: $Message" -ForegroundColor Yellow
    $script:updated++
}

function Write-Failed {
    param([string]$Message)
    Write-Host "  ‚ùå Failed:  $Message" -ForegroundColor Red
    $script:failed++
}

function Write-Info {
    param([string]$Message)
    Write-Host "  ‚ÑπÔ∏è  $Message" -ForegroundColor Cyan
}

function New-RandomPassword {
    param([int]$Length = 32)
    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    -join ((1..$Length) | ForEach-Object { $chars[(Get-Random -Maximum $chars.Length)] })
}

# ============================================================================
# VAULT REST API FUNCTIONS (using curl.exe)
# ============================================================================

function Invoke-VaultApi {
    param(
        [string]$Method = "GET",
        [string]$Path,
        [string]$Namespace = "",
        [string]$Body = ""
    )
    
    $uri = "$VaultAddr/v1/$Path"
    
    $curlArgs = @(
        "-s",
        "-X", $Method,
        "-H", "X-Vault-Token: $VaultToken",
        "-H", "Content-Type: application/json"
    )
    
    if ($Namespace) {
        $curlArgs += @("-H", "X-Vault-Namespace: $Namespace")
    }
    
    if ($Body) {
        $curlArgs += @("-d", $Body)
    }
    
    $curlArgs += $uri
    
    $response = & curl.exe @curlArgs 2>$null
    return $response
}

function Test-VaultConnection {
    try {
        $response = Invoke-VaultApi -Method "GET" -Path "sys/health"
        $json = $response | ConvertFrom-Json
        return @{
            Connected = $true
            Sealed = $json.sealed
            Version = $json.version
        }
    } catch {
        return @{
            Connected = $false
            Error = $_.Exception.Message
        }
    }
}

function Test-VaultNamespaceExists {
    param(
        [string]$Name,
        [string]$ParentNamespace = ""
    )
    
    $response = Invoke-VaultApi -Method "GET" -Path "sys/namespaces/$Name" -Namespace $ParentNamespace
    if ($response -match '"path"') {
        return $true
    }
    return $false
}

function New-VaultNamespace {
    param(
        [string]$Name,
        [string]$ParentNamespace = ""
    )
    
    if ($DryRun) {
        Write-Host "    [DRY RUN] Would create namespace: $Name in $ParentNamespace" -ForegroundColor DarkGray
        return $true
    }
    
    # Check if namespace already exists
    if (Test-VaultNamespaceExists -Name $Name -ParentNamespace $ParentNamespace) {
        Write-Host "  ‚úÖ Namespace exists: $Name" -ForegroundColor DarkGray
        return $true
    }
    
    # Create namespace
    $response = Invoke-VaultApi -Method "POST" -Path "sys/namespaces/$Name" -Namespace $ParentNamespace
    
    if ($response -match '"path"' -or $response -match 'already exists') {
        Write-Host "  ‚úÖ Created namespace: $Name" -ForegroundColor Green
        $script:namespacesCreated++
        return $true
    }
    
    if ($response -match 'already exists') {
        Write-Host "  ‚úÖ Namespace exists: $Name" -ForegroundColor DarkGray
        return $true
    }
    
    Write-Host "  ‚ùå Failed to create namespace $Name : $response" -ForegroundColor Red
    return $false
}

function Enable-VaultKvEngine {
    param(
        [string]$Namespace,
        [string]$Path = "secret"
    )
    
    if ($DryRun) {
        Write-Host "    [DRY RUN] Would enable KV v2 at $Path in namespace $Namespace" -ForegroundColor DarkGray
        return $true
    }
    
    # Write body to temp file
    $tempFile = [System.IO.Path]::GetTempFileName()
    [System.IO.File]::WriteAllText($tempFile, '{"type":"kv","options":{"version":"2"}}', [System.Text.Encoding]::UTF8)
    
    try {
        $uri = "$VaultAddr/v1/sys/mounts/$Path"
        
        $response = & curl.exe -s -X POST `
            -H "X-Vault-Token: $VaultToken" `
            -H "X-Vault-Namespace: $Namespace" `
            -H "Content-Type: application/json" `
            -d "@$tempFile" `
            $uri 2>$null
        
        if ($response -match 'existing mount' -or $response -match 'path is already in use') {
            Write-Host "  ‚úÖ KV engine already exists at: $Path" -ForegroundColor DarkGray
            return $true
        }
        
        if ([string]::IsNullOrEmpty($response)) {
            Write-Host "  ‚úÖ Enabled KV v2 at: $Path" -ForegroundColor Green
            return $true
        }
        
        if ($response -match 'error') {
            Write-Host "  ‚ö†Ô∏è  KV engine: $response" -ForegroundColor Yellow
            return $true  # Continue anyway
        }
        
        Write-Host "  ‚úÖ Enabled KV v2 at: $Path" -ForegroundColor Green
        return $true
    } finally {
        Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
    }
}

function Set-VaultSecret {
    param(
        [string]$Namespace,
        [string]$Path,
        [hashtable]$Data
    )
    
    if ($DryRun) {
        Write-Host "    [DRY RUN] PUT $KvMount/data/$Path in $Namespace" -ForegroundColor DarkGray
        $script:created++
        return $true
    }
    
    Write-Host "      Building JSON..." -ForegroundColor DarkGray
    
    # Build JSON string manually
    $sb = New-Object System.Text.StringBuilder
    [void]$sb.Append('{"data":{')
    
    $first = $true
    foreach ($key in $Data.Keys) {
        if (-not $first) { [void]$sb.Append(',') }
        $first = $false
        
        $value = $Data[$key]
        if ($value -eq $null) { $value = "" }
        
        # Escape for JSON
        $escaped = $value.ToString()
        $escaped = $escaped.Replace('\', '\\')
        $escaped = $escaped.Replace('"', '\"')
        $escaped = $escaped.Replace("`r", '\r')
        $escaped = $escaped.Replace("`n", '\n')
        $escaped = $escaped.Replace("`t", '\t')
        
        [void]$sb.Append('"')
        [void]$sb.Append($key)
        [void]$sb.Append('":"')
        [void]$sb.Append($escaped)
        [void]$sb.Append('"')
    }
    
    [void]$sb.Append('}}')
    $body = $sb.ToString()
    
    Write-Host "      Writing temp file ($($body.Length) bytes)..." -ForegroundColor DarkGray
    $tempFile = [System.IO.Path]::GetTempFileName()
    [System.IO.File]::WriteAllText($tempFile, $body, (New-Object System.Text.UTF8Encoding $false))
    
    try {
        $uri = "$VaultAddr/v1/$KvMount/data/$Path"
        Write-Host "      Calling: $uri" -ForegroundColor DarkGray
        
        $response = & curl.exe -s -X POST `
            -H "X-Vault-Token: $VaultToken" `
            -H "X-Vault-Namespace: $Namespace" `
            -H "Content-Type: application/json" `
            -d "@$tempFile" `
            $uri 2>$null
        
        Write-Host "      Response received" -ForegroundColor DarkGray
        
        if ($response -match '"version"' -or $response -match '"created_time"') {
            Write-Created "$Path"
            return $true
        }
        
        if ($response -match 'error') {
            Write-Failed "$Path - $response"
            return $false
        }
        
        Write-Created "$Path"
        return $true
    } finally {
        Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
    }
}

# ============================================================================
# COSIGN KEY FUNCTIONS
# ============================================================================

function Get-CosignKeysFromFolder {
    param([string]$ServiceName)
    
    Write-Host "    Looking for: $CosignKeysDir\$ServiceName" -ForegroundColor DarkGray
    
    $serviceDir = Join-Path $CosignKeysDir $ServiceName
    $keyFile = Join-Path $serviceDir "cosign.key"
    $pubFile = Join-Path $serviceDir "cosign.pub"
    $pwdFile = Join-Path $serviceDir "password.txt"
    
    Write-Host "    Checking $keyFile" -ForegroundColor DarkGray
    if (-not (Test-Path $keyFile)) {
        Write-Failed "Cosign key not found: $keyFile"
        return $null
    }
    
    Write-Host "    Checking $pubFile" -ForegroundColor DarkGray
    if (-not (Test-Path $pubFile)) {
        Write-Failed "Cosign public key not found: $pubFile"
        return $null
    }
    
    Write-Host "    Checking $pwdFile" -ForegroundColor DarkGray
    if (-not (Test-Path $pwdFile)) {
        Write-Failed "Cosign password not found: $pwdFile"
        return $null
    }
    
    Write-Host "    Reading files..." -ForegroundColor DarkGray
    $privateKey = Get-Content $keyFile -Raw
    Write-Host "    Private key: $($privateKey.Length) chars" -ForegroundColor DarkGray
    
    $publicKey = Get-Content $pubFile -Raw
    Write-Host "    Public key: $($publicKey.Length) chars" -ForegroundColor DarkGray
    
    $password = (Get-Content $pwdFile -Raw).Trim()
    Write-Host "    Password: $($password.Length) chars" -ForegroundColor DarkGray
    
    return @{
        private_key = $privateKey
        public_key = $publicKey
        password = $password
    }
}

# ============================================================================
# LYNX API FUNCTIONS (using curl.exe)
# ============================================================================

function Invoke-LynxApi {
    param(
        [string]$Method = "GET",
        [string]$Path,
        [string]$Body = ""
    )
    
    $uri = "$LynxAddr$Path"
    
    if ($Body) {
        # Write body to temp file
        $tempFile = [System.IO.Path]::GetTempFileName()
        [System.IO.File]::WriteAllText($tempFile, $Body, [System.Text.Encoding]::UTF8)
        
        try {
            $response = & curl.exe -s -X $Method `
                -H "X-Api-Key: $LynxApiKey" `
                -H "Content-Type: application/json" `
                -d "@$tempFile" `
                $uri 2>$null
            return $response
        } finally {
            Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
        }
    } else {
        $response = & curl.exe -s -X $Method `
            -H "X-Api-Key: $LynxApiKey" `
            -H "Content-Type: application/json" `
            $uri 2>$null
        return $response
    }
}

function Get-LynxProjects {
    try {
        $response = Invoke-LynxApi -Method "GET" -Path "/api/v1/project"
        return $response | ConvertFrom-Json
    } catch {
        Write-Failed "Failed to fetch Lynx projects: $($_.Exception.Message)"
        return $null
    }
}

function New-LynxProject {
    param(
        [string]$Name,
        [string]$Slug,
        [string]$TeamId
    )
    
    if ($DryRun) {
        Write-Host "    [DRY RUN] Would create Lynx project: $Slug" -ForegroundColor DarkGray
        return @{ id = "dry-run-id"; slug = $Slug }
    }
    
    # Build JSON manually
    $escapedName = $Name.Replace('\', '\\').Replace('"', '\"')
    $escapedSlug = $Slug.Replace('\', '\\').Replace('"', '\"')
    $escapedDesc = "Terraform service for $Name".Replace('\', '\\').Replace('"', '\"')
    
    if ($TeamId) {
        $body = "{`"name`":`"$escapedName`",`"slug`":`"$escapedSlug`",`"description`":`"$escapedDesc`",`"team`":{`"id`":`"$TeamId`"}}"
    } else {
        $body = "{`"name`":`"$escapedName`",`"slug`":`"$escapedSlug`",`"description`":`"$escapedDesc`"}"
    }
    
    $response = Invoke-LynxApi -Method "POST" -Path "/api/v1/project" -Body $body
    
    if ([string]::IsNullOrEmpty($response)) {
        return $null
    }
    
    try {
        $result = $response | ConvertFrom-Json -ErrorAction Stop
        if ($result.id) {
            Write-Host "  ‚úÖ Created Lynx project: $Slug" -ForegroundColor Green
            $script:lynxProjectsCreated++
            return $result
        }
    } catch {
        # Ignore parse errors
    }
    
    return $null
}

function Get-LynxEnvironments {
    param([string]$ProjectId)
    
    try {
        $response = Invoke-LynxApi -Method "GET" -Path "/api/v1/project/$ProjectId/environment"
        return $response | ConvertFrom-Json
    } catch {
        return $null
    }
}

function New-LynxEnvironment {
    param(
        [string]$ProjectId,
        [string]$Name,
        [string]$Slug
    )
    
    if ($DryRun) {
        Write-Host "    [DRY RUN] Would create Lynx environment: $Slug" -ForegroundColor DarkGray
        return @{ 
            id = "dry-run-id"
            slug = $Slug
            username = "dry-run-user"
            secret = "dry-run-secret"
        }
    }
    
    $username = "tf-$Slug-$(New-RandomPassword -Length 8)"
    $secret = New-RandomPassword -Length 32
    
    # Build JSON manually
    $escapedName = $Name.Replace('\', '\\').Replace('"', '\"')
    $escapedSlug = $Slug.Replace('\', '\\').Replace('"', '\"')
    
    $body = "{`"name`":`"$escapedName`",`"slug`":`"$escapedSlug`",`"username`":`"$username`",`"secret`":`"$secret`"}"
    
    $response = Invoke-LynxApi -Method "POST" -Path "/api/v1/project/$ProjectId/environment" -Body $body
    
    if ([string]::IsNullOrEmpty($response)) {
        return $null
    }
    
    try {
        $result = $response | ConvertFrom-Json -ErrorAction Stop
        if ($result.id) {
            Write-Host "  ‚úÖ Created Lynx environment: $Slug" -ForegroundColor Green
            $script:lynxEnvsCreated++
            return $result
        }
    } catch {
        # Ignore parse errors
    }
    
    return $null
}

function Get-OrCreateLynxCredentials {
    param([string]$ServiceName)
    
    $projectSlug = "terraform-services-$ServiceName"
    $projectName = "Terraform Services - $((Get-Culture).TextInfo.ToTitleCase($ServiceName))"
    
    try {
        $projectsResponse = Get-LynxProjects
        if (-not $projectsResponse -or -not $projectsResponse.projects) {
            Write-Host "    ‚ö†Ô∏è Could not fetch Lynx projects" -ForegroundColor Yellow
            return $null
        }
        
        $project = $projectsResponse.projects | Where-Object { $_.slug -eq $projectSlug }
        
        if (-not $project) {
            Write-Info "Creating Lynx project: $projectSlug"
            $project = New-LynxProject -Name $projectName -Slug $projectSlug -TeamId $LynxTeamId
            if (-not $project) {
                Write-Host "    ‚ö†Ô∏è Could not create Lynx project, using placeholders" -ForegroundColor Yellow
                return $null
            }
        } else {
            Write-Host "    ‚úÖ Lynx project exists: $projectSlug" -ForegroundColor DarkGray
        }
        
        $envsResponse = Get-LynxEnvironments -ProjectId $project.id
        
        $prdEnv = $null
        if ($envsResponse -and $envsResponse.environments) {
            $prdEnv = $envsResponse.environments | Where-Object { $_.slug -eq "prd" }
        }
        
        if (-not $prdEnv) {
            Write-Info "Creating Lynx prd environment for: $projectSlug"
            $prdEnv = New-LynxEnvironment -ProjectId $project.id -Name "Production" -Slug "prd"
            if (-not $prdEnv) {
                Write-Host "    ‚ö†Ô∏è Could not create Lynx environment, using placeholders" -ForegroundColor Yellow
                return $null
            }
        } else {
            Write-Host "    ‚úÖ Lynx prd environment exists" -ForegroundColor DarkGray
        }
        
        return @{
            lynx_username = $prdEnv.username
            lynx_password = $prdEnv.secret
        }
    } catch {
        Write-Host "    ‚ö†Ô∏è Lynx error: $($_.Exception.Message)" -ForegroundColor Yellow
        return $null
    }
}

# ============================================================================
# PROVIDER PLACEHOLDERS
# ============================================================================

function Get-ProviderPlaceholders {
    param([string]$ServiceName)
    
    $serviceProviders = @{
        "axiom" = @{ "axiom" = @{ api_token = "PLACEHOLDER"; org_id = "PLACEHOLDER" } }
        "buildkite" = @{ "buildkite" = @{ api_token = "PLACEHOLDER"; organization = "PLACEHOLDER" } }
        "cloudflare" = @{ "cloudflare" = @{ api_token = "PLACEHOLDER"; account_id = "PLACEHOLDER" } }
        "netlify" = @{ "netlify" = @{ api_token = "PLACEHOLDER" } }
        "ngrok" = @{ "ngrok" = @{ api_key = "PLACEHOLDER" } }
        "teamcity" = @{ "teamcity" = @{ url = "https://teamcity.example.com"; token = "PLACEHOLDER" } }
        "octopusdeploy" = @{ "octopusdeploy" = @{ server_url = "https://octopus.example.com"; api_key = "PLACEHOLDER" } }
        "splunk" = @{ "splunk" = @{ url = "https://splunk.example.com:8089"; auth_token = "PLACEHOLDER" } }
        "elastic" = @{ "elasticsearch" = @{ url = "https://elasticsearch.example.com:9200"; api_key = "PLACEHOLDER" } }
        "netbox" = @{ "netbox" = @{ server_url = "https://netbox.example.com"; api_token = "PLACEHOLDER" } }
        "vmware" = @{ "vsphere" = @{ server = "vcenter.example.com"; user = "admin"; password = "PLACEHOLDER" } }
        "argocd" = @{ "argocd" = @{ server = "argocd.example.com"; auth_token = "PLACEHOLDER" } }
        "cloudsmith" = @{ "cloudsmith" = @{ api_key = "PLACEHOLDER"; organization = "PLACEHOLDER" } }
        "terrapwner" = @{ "terrapwner" = @{ api_key = "PLACEHOLDER" } }
        "mondoo" = @{ "mondoo" = @{ api_token = "PLACEHOLDER"; space_id = "PLACEHOLDER" } }
        "grafana" = @{ "grafana" = @{ url = "https://grafana.example.com"; auth = "PLACEHOLDER" } }
        "gns3" = @{ "gns3" = @{ server = "gns3.example.com"; api_key = "PLACEHOLDER" } }
        "lynx" = @{ "lynx" = @{ base_url = "https://lynx.example.com"; api_token = "PLACEHOLDER" } }
        "archestra" = @{ "archestra" = @{ server = "archestra.example.com"; api_key = "PLACEHOLDER" } }
        "kestra" = @{ "kestra" = @{ url = "https://kestra.example.com"; api_token = "PLACEHOLDER" } }
        "nirmata" = @{ "nirmata" = @{ url = "https://nirmata.example.com"; api_token = "PLACEHOLDER" } }
        "checkly" = @{ "checkly" = @{ api_key = "PLACEHOLDER"; account_id = "PLACEHOLDER" } }
        "portio" = @{ "portio" = @{ api_key = "PLACEHOLDER" } }
        "sentry" = @{ "sentry" = @{ url = "https://sentry.io"; auth_token = "PLACEHOLDER" } }
        "tailscale" = @{ "tailscale" = @{ api_key = "PLACEHOLDER"; tailnet = "PLACEHOLDER" } }
        "vault" = @{ "vault" = @{ address = "https://vault.example.com:8200"; token = "PLACEHOLDER" } }
        "harbor" = @{ "harbor" = @{ url = "https://harbor.example.com"; username = "admin"; password = "PLACEHOLDER" } }
    }
    
    if ($serviceProviders.ContainsKey($ServiceName)) {
        return $serviceProviders[$ServiceName]
    }
    
    return @{}
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

Write-Header "Vault Secrets Bootstrap Script"

Write-Host "`nConfiguration:" -ForegroundColor Yellow
Write-Host "  Vault Address:    $VaultAddr"
Write-Host "  Root Namespace:   $RootNamespace"
Write-Host "  KV Mount:         $KvMount"
Write-Host "  Cosign Keys Dir:  $CosignKeysDir"
Write-Host "  Lynx Address:     $LynxAddr"
Write-Host "  Services:         $($services.Count)"
Write-Host "  Dry Run:          $DryRun"

if ($DryRun) {
    Write-Host "`n‚ö†Ô∏è  DRY RUN MODE - No changes will be made" -ForegroundColor Yellow
}

# Verify prerequisites
Write-Header "Verifying Prerequisites"

# Check curl
$curlPath = Get-Command curl.exe -ErrorAction SilentlyContinue
if (-not $curlPath) {
    Write-Host "  ‚ùå curl.exe not found in PATH" -ForegroundColor Red
    exit 1
}
Write-Host "  ‚úÖ curl.exe found" -ForegroundColor Green

# Check Vault connection
if (-not $DryRun) {
    $vaultStatus = Test-VaultConnection
    if ($vaultStatus.Connected) {
        Write-Host "  ‚úÖ Vault connected (v$($vaultStatus.Version), sealed: $($vaultStatus.Sealed))" -ForegroundColor Green
    } else {
        Write-Host "  ‚ùå Cannot connect to Vault: $($vaultStatus.Error)" -ForegroundColor Red
        exit 1
    }
}

# Check Cosign keys directory
if (Test-Path $CosignKeysDir) {
    $keyCount = (Get-ChildItem $CosignKeysDir -Directory).Count
    Write-Host "  ‚úÖ Cosign keys directory found ($keyCount services)" -ForegroundColor Green
} else {
    Write-Host "  ‚ùå Cosign keys directory not found: $CosignKeysDir" -ForegroundColor Red
    Write-Host "     Run Generate-CosignKeysPerService.ps1 first" -ForegroundColor Yellow
    exit 1
}

# Check Lynx connectivity
$lynxConnected = $false
if (-not $DryRun) {
    try {
        $lynxProjects = Get-LynxProjects
        if ($lynxProjects -ne $null) {
            Write-Host "  ‚úÖ Lynx connected (found $($lynxProjects.totalCount) projects)" -ForegroundColor Green
            $lynxConnected = $true
        }
    } catch {
        Write-Host "  ‚ö†Ô∏è  Cannot connect to Lynx - will use placeholders" -ForegroundColor Yellow
    }
}

try {
    foreach ($service in $services) {
        $serviceNamespace = "$RootNamespace/$service"
        $prdNamespace = "$serviceNamespace/prd"
        
        Write-Header "Service: $service"
        Write-Host "  Namespace: $prdNamespace" -ForegroundColor DarkGray
        
        # 1. Create service namespace if needed
        Write-Host "  ‚Üí Creating service namespace..." -ForegroundColor White
        if (-not (New-VaultNamespace -Name $service -ParentNamespace $RootNamespace)) {
            Write-Failed "Could not create service namespace, skipping"
            continue
        }
        
        # 2. Create prd namespace under service
        Write-Host "  ‚Üí Creating prd namespace..." -ForegroundColor White
        if (-not (New-VaultNamespace -Name "prd" -ParentNamespace $serviceNamespace)) {
            Write-Failed "Could not create prd namespace, skipping"
            continue
        }
        
        # 3. Enable KV engine in prd namespace
        Write-Host "  ‚Üí Enabling KV engine..." -ForegroundColor White
        Enable-VaultKvEngine -Namespace $prdNamespace -Path $KvMount | Out-Null
        
        # 4. Read and store Cosign keys from local folder
        Write-Host "  ‚Üí Cosign keys..." -ForegroundColor White
        Write-Host "    Reading from folder..." -ForegroundColor DarkGray
        $cosignKeys = Get-CosignKeysFromFolder -ServiceName $service
        if ($cosignKeys) {
            Write-Host "    Keys loaded, calling curl..." -ForegroundColor DarkGray
            $result = Set-VaultSecret -Namespace $prdNamespace -Path "cosign" -Data $cosignKeys
            Write-Host "    Done." -ForegroundColor DarkGray
        } else {
            Write-Host "    ‚ö†Ô∏è No cosign keys found, skipping" -ForegroundColor Yellow
        }
        
        # 5. Get or create Lynx credentials
        Write-Host "  ‚Üí Lynx credentials..." -ForegroundColor White
        if (-not $DryRun) {
            $lynxCreds = $null
            if ($lynxConnected) {
                $lynxCreds = Get-OrCreateLynxCredentials -ServiceName $service
            }
            
            if ($lynxCreds) {
                Set-VaultSecret -Namespace $prdNamespace -Path "lynx_username" -Data @{ value = $lynxCreds.lynx_username } | Out-Null
                Set-VaultSecret -Namespace $prdNamespace -Path "lynx_password" -Data @{ value = $lynxCreds.lynx_password } | Out-Null
            } else {
                Set-VaultSecret -Namespace $prdNamespace -Path "lynx_username" -Data @{ value = "PLACEHOLDER" } | Out-Null
                Set-VaultSecret -Namespace $prdNamespace -Path "lynx_password" -Data @{ value = "PLACEHOLDER" } | Out-Null
            }
        } else {
            Write-Host "    [DRY RUN] Would create Lynx credentials" -ForegroundColor DarkGray
            $script:created += 2
        }
        
        # 6. Create provider secrets
        $providerSecrets = Get-ProviderPlaceholders -ServiceName $service
        foreach ($provider in $providerSecrets.Keys) {
            Write-Host "  ‚Üí providers/$provider..." -ForegroundColor White
            Set-VaultSecret -Namespace $prdNamespace -Path "providers/$provider" -Data $providerSecrets[$provider] | Out-Null
        }
    }
    
    Write-Header "Summary"
    Write-Host "`n  Vault:" -ForegroundColor White
    Write-Host "    Namespaces created: $($script:namespacesCreated)" -ForegroundColor Green
    Write-Host "    Secrets created:    $($script:created)" -ForegroundColor Green
    Write-Host "    Secrets updated:    $($script:updated)" -ForegroundColor Yellow
    Write-Host "    Failed:             $($script:failed)" -ForegroundColor $(if ($script:failed -gt 0) { "Red" } else { "White" })
    
    Write-Host "`n  Lynx:" -ForegroundColor White
    Write-Host "    Projects created:     $($script:lynxProjectsCreated)" -ForegroundColor Green
    Write-Host "    Environments created: $($script:lynxEnvsCreated)" -ForegroundColor Green
    
    if ($DryRun) {
        Write-Host "`n‚ö†Ô∏è  DRY RUN - No changes were made" -ForegroundColor Yellow
    }
    
    Write-Host "`nüìã Vault Structure:" -ForegroundColor Cyan
    Write-Host "  Namespace: $RootNamespace/{service}/prd" -ForegroundColor White
    Write-Host "    ‚îî‚îÄ‚îÄ $KvMount/data/" -ForegroundColor DarkGray
    Write-Host "        ‚îú‚îÄ‚îÄ cosign" -ForegroundColor DarkGray
    Write-Host "        ‚îú‚îÄ‚îÄ lynx_username" -ForegroundColor DarkGray
    Write-Host "        ‚îú‚îÄ‚îÄ lynx_password" -ForegroundColor DarkGray
    Write-Host "        ‚îî‚îÄ‚îÄ providers/{name}" -ForegroundColor DarkGray

} finally {
    # Nothing to clean up
}

exit $(if ($script:failed -gt 0) { 1 } else { 0 })
